// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
#ifndef KUDU_CFILE_COMPRESSION_CODEC_H
#define KUDU_CFILE_COMPRESSION_CODEC_H

#include <cstddef>
#include <cstdint>
#include <optional>
#include <string>
#include <vector>
#include <memory>

#include <glog/logging.h>
#include <snappy-stubs-public.h>

#include "kudu/gutil/strings/substitute.h"
#include "kudu/util/compression/compression.pb.h"
#include "kudu/util/slice.h"
#include "kudu/util/status.h"

namespace kudu {

class CompressionCodec {
 public:
  CompressionCodec();
  virtual ~CompressionCodec();

  Status CompressWithStats(
      const Slice& input,
      uint8_t* compressed,
      size_t* compressed_length) {
    Status ret = Compress(input, compressed, compressed_length);
    ++total_compressions_;
    if (ret.ok()) {
      total_bytes_before_compression_ += input.size();
      total_bytes_after_compression_ += *compressed_length;
    } else {
      ++total_compression_errors_;
    }
    return ret;
  }

  // REQUIRES: "compressed" must point to an area of memory that is at
  // least "MaxCompressedLength(input_length)" bytes in length.
  //
  // Takes the data stored in "input[0..input_length]" and stores
  // it in the array pointed to by "compressed".
  //
  // returns the length of the compressed output.
  virtual Status Compress(
      const Slice& input,
      uint8_t* compressed,
      size_t* compressed_length) = 0;

  virtual Status Compress(
      const std::vector<Slice>& input_slices,
      uint8_t* compressed,
      size_t* compressed_length) = 0;

  Status UncompressWithStats(
      const Slice& compressed,
      uint8_t* uncompressed,
      size_t uncompressed_length) {
    Status ret = Uncompress(compressed, uncompressed, uncompressed_length);
    ++total_decompressions_;
    if (ret.ok()) {
      total_bytes_before_decompression_ += compressed.size();
      total_bytes_after_decompression_ += uncompressed_length;
    } else {
      ++total_decompression_errors_;
    }
    return ret;
  }

  // Given data in "compressed[0..compressed_length-1]" generated by
  // calling the Compress routine, this routine stores the uncompressed data
  // to uncompressed[0..uncompressed_length-1]
  // returns false if the message is corrupted and could not be uncompressed
  virtual Status Uncompress(
      const Slice& compressed,
      uint8_t* uncompressed,
      size_t uncompressed_length) = 0;

  // Returns the maximal size of the compressed representation of
  // input data that is "source_bytes" bytes in length.
  virtual size_t MaxCompressedLength(size_t source_bytes) const = 0;

  // Returns a JSON which contains stats
  virtual std::string Stats() const;

  // Sets a compression dictionary
  virtual Status SetDictionary(const std::string& /*dict*/) {
    LOG(WARNING) << "Dictionary compression is not supported by "
                 << CompressionType_Name(type());
    return Status::OK();
  }

  // Returns dictionary if dictionary compression is used
  virtual std::string GetDictionary() const {
    return {};
  }

  // Sets compression level
  virtual Status SetCompressionLevel(int level) {
    compression_level_ = level;
    return Status::OK();
  }

  virtual int CompressionLevel() const {
    return compression_level_;
  }

  // Return the type of compression implemented by this codec.
  virtual CompressionType type() const = 0;

 protected:
  int compression_level_ = 0;

 private:
  // Stats
  uint64_t total_bytes_before_compression_ = 0;
  uint64_t total_bytes_after_compression_ = 0;
  uint64_t total_compressions_ = 0;
  uint64_t total_bytes_before_decompression_ = 0;
  uint64_t total_bytes_after_decompression_ = 0;
  uint64_t total_decompressions_ = 0;
  uint64_t total_compression_errors_ = 0;
  uint64_t total_decompression_errors_ = 0;

  DISALLOW_COPY_AND_ASSIGN(CompressionCodec);
};

/**
 * Manages global compression codec, dictionary and compression level
 *
 * This class is NOT thread safe. In the commit path we rely on taking
 * RaftConsensus::lock_ and PeerConsensusQueue::queue_lock_ while updating
 * codec, dict, level etc. and also compression and decompression using the
 * codec
 */
class CompressionCodecManager {
 public:
  static Status GetCodec(
      CompressionType type,
      std::shared_ptr<CompressionCodec>* codec);

  static Status GetCodec(
      const std::string& type,
      std::shared_ptr<CompressionCodec>* codec) {
    return GetCodec(GetCodecType(type), codec);
  }

  static std::shared_ptr<CompressionCodec> GetCurrentCodec() {
    return codec_;
  }

  static Status SetCurrentCodec(CompressionType type);

  static Status SetCurrentCodec(const std::string& type) {
    return SetCurrentCodec(GetCodecType(type));
  }

  static const std::string& GetDictionary() {
    return dictionary_;
  }

  static Status SetDictionary(const std::string& dict);

  static unsigned int GetCurrentDictionaryID();

  static unsigned int GetDictionaryID(const std::string& dict);

  static Status SetCurrentCompressionLevel(int level);

  static CompressionType GetCodecType(const std::string& name) {
    CompressionType type;
    if (!CompressionType_Parse(name, &type)) {
      LOG(WARNING) << "Unable to recognize the compression codec '" << name
                   << "' using no compression as default.";
      return NO_COMPRESSION;
    }
    return type;
  }

  static std::string GetCodecName(CompressionType type) {
    return CompressionType_Name(type);
  }

 private:
  CompressionCodecManager() {}

  static std::shared_ptr<CompressionCodec> codec_;
  static std::string dictionary_;
  static int level_;

  DISALLOW_COPY_AND_ASSIGN(CompressionCodecManager);
};

} // namespace kudu
#endif
